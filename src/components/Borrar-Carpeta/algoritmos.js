
// Given n pairs of parenthesis, white a function to generate all combinations of well-formed parenthessis
// input = 3
// output = [
//                 "((()))", 
//                 "(()())", 
//                 "()(())", 
//                 "()()()"]

const generateParenthesis = (n) => {
    const solution = [];

    const generateCombo = (leftPCount, rightPCount, partial) => {
        if(leftPCount > rightPCount) return 
        if(!leftPCount && !rightPCount) solution.push(partial);

        if(leftPCount > 0) generateCombo(leftPCount -1, rightPCount, partial + '(');
        if(rightPCount > 0) generateCombo(leftPCount, rightPCount -1, partial + ')');


    }

    generateCombo(n,n,'');
    return solution
}

console.log(generateParenthesis(3))


// Given a binary TreeWalker, find its maximum depth.
// The maximum depth is the number of nodes along the longest path from the root node down 
// to the farthest leaf node.

// Note: a leaf is a node with no children

// example : binary tree[3, 9, 20, null, null, 15, 7]
//     3
//    / \
//   9   20
//       /\  
//     15  7
// returns  its a DEPTH = 3
// solution   https://www.youtube.com/watch?v=a4LNgiIcBTU
// function TreeNode(val, left, right) {
//          this.val = (val===undefined ? 0 : val)
//          this.left = (left===undefined ? null : left)
//          this.right = (right===undefined ? null : right)
//      }
     
     

const SolutionMaxDepth = (root) => {
    // desde aqui 
    let maxDepth= 0;
    let BFS = (node, level) => {
        if(node === null) return 
        if(level > maxDepth) maxDepth = level;
        BFS(node.left, level +1)
        BFS(node.right, level +1)
    }
    BFS(root, 1);
    return maxDepth
    // para ak todo bien
}

let root = [3, 9, 20, null, null, 15, 7]

console.log(SolutionMaxDepth(root)) 


/*   Two Sum less than K
Given an array A of integers and integer K, return the maximum S such that there exists i < j with A[i] + A[j] = S and S < K. If no i, j exist satisfying this equation, return -1.
Exxample 1

Input: A = [34,23,1,24,75,33,54,8], K = 60

Output: 58
Explanation: 
We can use 34 and 24 to sum 58 which is less than 60.

Expple 2
Input: A = [10,20,30], K = 15
Output: -1
Explanation: 
In this case it's not possible to get a pair sum less that 15.

*/

const twoSumLessThank = function (A, K){
    let max = -1;
    for(let i = 0; i < A.length; i++){
        for(let j = i +1; j < A.length; j++){
            const currSum = A[i] + A[j];
            if(currSum < K && currSum > max){
                max = currSum
            }
        }
    }

    return max
}

let A = [34,23,1,24,75,33,54,8];
let K = 60
console.log(twoSumLessThank(A, K))





/// max level sum  total de arbol
/// sumando los valores del arbol 

var maxLevelSum = function(root){
    const queue = [root];
    let res= 0, cur = 0, resSum=0;
    while(queue.length){
        ++cur;
        const SIZE =queue.length;
        let SUM = 0;
        for( let i= 0; i < SIZE; ++i){
            const f = queue.shift();
            if(f.left) queue.push(f.left);
            if(f.right) queue.push(f.right);
            SUM += f.val
        }
        res = SUM > resSum ? cur : res;
        resSum = Math.max(resSum, SUM);
    }

    return res
}


// You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position.
// Return the letter that was added to t.

/* Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.

Example 2:

Input: s = "", t = "y"
Output: "y"
 */

const  findTheDifference = (s, t) => {
    let stringOne = s.split('').sort();
    let stringTwo = t.split('').sort();
    for(let i = 0; i < stringTwo.length; i++){
        if(stringTwo[i] !== stringOne[i]){
            return stringTwo[i]
        }
    }
};

let s = "abcd"
let t = "abcde" 
console.log(findTheDifference(s, t))


// Two Sum 
// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

// You may assume that each input would have exactly one solution, and you may not use the same element twice.

// You can return the answer in any order.

/* Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 */

const twoSum = function (nums, target){
    const map = new Map();
    // look speed in map is o(1)
    for(let i= 0; i < nums.length; i++){
        let currVal = nums[i];
        if(map.has(currVal)){
            return [map.get(currVal), i];
        }
        let diff = target - currVal;
        map.set(diff, i)
    }
}